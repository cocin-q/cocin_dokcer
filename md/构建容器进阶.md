# 构建容器进阶

## 实现容器的后台运行

### 实现-d标签

```go
// run命令
var runCommand = cli.Command{
   ...
   Flags: []cli.Flag{ // 类似运行命令时使用 -- 来指定参数
      ...
      cli.BoolFlag{
         Name:  "d",
         Usage: "detach container",
      },
   },
   /* 这里是run命令执行的真正函数
   1. 判断参数是否包含command
   2. 获取用户指定的command
   3. 调用Run function 去准备启动容器
   */
   Action: func(context *cli.Context) error {
      ...
      detach := context.Bool("d")
      if tty && detach { // tty 相当于前台交互模式 detach是后台运行模式
         return fmt.Errorf("ti and d paramter can not both provided")
      }
      ...
      log.Infof("tty: %v", tty)
      Run(tty, cmdArray, resConf, volume)
      return nil
   },
}
```

​		记得修改Run中的逻辑，如果不是attach模式（前台交互），那parent就可以退出了。

```go
if tty {
   parent.Wait()

   mntURL := "/root/mnt/"
   rootURL := "/root/"
   container.DeleteWorkSpace(rootURL, mntURL, volume)
}
```

## 实现查看运行中的容器

​		利用docker ps命令实现查看有哪些容器在运行。主要是去约定好的位置查询一下容器的数据信息，然后显示出来，因此数据准备就显得尤为重要。

### 准备数据

​		关于容器的信息，比如PID、容器创建时间、容器运行命令等之前都没有记录，导致容器运行完用户就再也不知道它的信息了，因此需要把这部分信息保留下来。

#### 添加name标签

​		方便用户指定容器名字。

```go
cli.StringFlag{
   Name:  "name",
   Usage: "container name",
},

// 传递下去
Run(tty, cmdArray, resConf, volume, containerName)
```

#### ID生成器，唯一标识容器

```go
// ID 生成器
func randStringBytes(n int) string {
   letterBytes := "1234567890"
   rand.Seed(time.Now().UnixNano())
   b := make([]byte, n)
   for i := range b {
      b[i] = letterBytes[rand.Intn(len(letterBytes))]
   }
   return string(b)
}
```

#### 定义容器的基本信息

​		默认把容器基本信息以json的形式存储在宿主机的 /var/run/cocin_docker/容器名/config.json 文件里面。

```go
var (
   RUNNING             string = "running"
   STOP                string = "stopped"
   Exit                string = "exited"
   DefaultInfoLocation string = "/var/run/cocin_docker/%s/"
   ConfigName          string = "config.json"
)

type ContainerInfo struct {
   Pid         string `json:"pid"`        //容器的init进程在宿主机上的 PID
   Id          string `json:"id"`         //容器Id
   Name        string `json:"name"`       //容器名
   Command     string `json:"command"`    //容器内init运行命令
   CreatedTime string `json:"createTime"` //创建时间
   Status      string `json:"status"`     //容器的状态
}
```

#### 记录容器基本信息

```go
// 记录容器的基本信息
func recordContainerInfo(containerPID int, commandArray []string, containerName string) (string, error) {
   // 生成ID
   id := randStringBytes(containerIDLength)
   // 当前时间作为创建时间
   createTime := time.Now().Format("2006-01-02 15:04:05")
   command := strings.Join(commandArray, "")
   // 没指定名字，按照ID来
   if containerName == "" {
      containerName = id
   }
   // 生成容器信息结构体
   containerInfo := &container.ContainerInfo{
      Pid:         strconv.Itoa(containerPID),
      Id:          id,
      Name:        containerName,
      Command:     command,
      CreatedTime: createTime,
      Status:      container.RUNNING,
   }

   // json序列化
   jsonBytes, err := json.Marshal(containerInfo)
   if err != nil {
      log.Errorf("Record container info error %v", err)
      return "", err
   }
   jsonStr := string(jsonBytes)

   // 拼凑存储容器信息的路径
   dirUrl := fmt.Sprintf(container.DefaultInfoLocation, containerName)
   // 路径不存在，级联的创建 如果目录已经存在，也返回nil
   if err := os.MkdirAll(dirUrl, 0622); err != nil {
      log.Errorf("Mkdir error %s error %v", dirUrl, err)
      return "", err
   }
   fileName := dirUrl + "/" + container.ConfigName
   // 创建最终配置文件 如果文件已存在，会将文件清空
   file, err := os.Create(fileName)
   defer file.Close()
   if err != nil {
      log.Errorf("Create file %s error %v", fileName, err)
      return "", err
   }
   // 将json序列化后的数据写入文件
   if _, err := file.WriteString(jsonStr); err != nil {
      log.Errorf("File write string error %v", err)
      return "", err
   }
   return containerName, nil
}
```

​		需要在Run函数中加上调用。

```go
// 记录容器信息
containerName, err := recordContainerInfo(parent.Process.Pid, comArray, containerName)
if err != nil {
   log.Errorf("Record container info error %v", err)
   return
}
```

#### 删除容器相关信息

​		如果使用的是attach模式，那容器在退出后，需要删除相关信息。即把对应目录删除即可。

```go
func deleteContainerInfo(containerId string) {
   dirURL := fmt.Sprintf(container.DefaultInfoLocation, containerId)
   if err := os.RemoveAll(dirURL); err != nil {
      log.Errorf("Remove dir %s error %v", dirURL, err)
   }
}
```

```go
if tty {
   parent.Wait()
   deleteContainerInfo(containerName)
}
```

### 实现cocin_docker ps

​		所有的容器运行信息都被存储到 /var/run/cocin_docker/容器名 下，只要遍历这个目录下的容器就可以实现命令。

#### 添加ps命令

​		首先，主函数里面注册。

```go
// 定义基本命令
app.Commands = []cli.Command{
   initCommand,
   runCommand,
   commitCommand,
   listCommand,
}
```

​		定义命令的具体实现。

```go
// ps命令
var listCommand = cli.Command{
   Name:  "ps",
   Usage: "list all the containers",
   Action: func(context *cli.Context) error {
      ListContainers()
      return nil
   },
}
```

```go
// ListContainers 列出容器信息
func ListContainers() {
   // 找到存储信息的路径 /var/run/cocin_docker
   dirURL := fmt.Sprintf(container.DefaultInfoLocation, "")
   // "/var/run/cocin_docker/%s/" 需要把后面那个 / 去掉
   dirURL = dirURL[:len(dirURL)-1]
   // 读取该文件夹下面所有文件
   files, err := ioutil.ReadDir(dirURL)
   if err != nil {
      log.Errorf("Read dir %s error %v", dirURL, err)
      return
   }
   var containers []*container.ContainerInfo
   // 遍历文件夹下面的所有文件
   for _, file := range files {
      // 根据容器配置文件获得对应信息，然后转换成容器信息的对象
      tmpContainer, err := getContainerInfo(file)
      if err != nil {
         log.Errorf("Get container info error %v", err)
         continue
      }
      containers = append(containers, tmpContainer)
   }

   // 使用tabwriter.NewWriter 在控制台打印容器信息
   // tabwriter 是引用的 text/tabwriter 类库，用于在控制台打印对齐的表格
   w := tabwriter.NewWriter(os.Stdout, 12, 1, 3, ' ', 0)
   fmt.Fprint(w, "ID\tNAME\tPID\tSTATUS\tCOMMAND\tCREATED\n")
   for _, item := range containers {
      fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\t%s\n",
         item.Id,
         item.Name,
         item.Pid,
         item.Status,
         item.Command,
         item.CreatedTime)
   }
   if err := w.Flush(); err != nil {
      log.Errorf("Flush error %v", err)
      return
   }
}

// 因为具体的容器信息在对应容器文件夹下，所以这里需要进入文件夹取出信息
func getContainerInfo(file os.FileInfo) (*container.ContainerInfo, error) {
   // 获取文件名
   containerName := file.Name()
   // 根据文件名生成文件绝对路径
   configFileDir := fmt.Sprintf(container.DefaultInfoLocation, containerName)
   configFileDir = configFileDir + container.ConfigName
   // 读取信息
   content, err := ioutil.ReadFile(configFileDir)
   if err != nil {
      log.Errorf("Read file %s error %v", configFileDir, err)
      return nil, err
   }
   // json反序列化
   var containerInfo container.ContainerInfo
   if err := json.Unmarshal(content, &containerInfo); err != nil {
      log.Errorf("Json unmarshal error %v", err)
      return nil, err
   }
   return &containerInfo, nil
}
```

## 查看容器日志

​		一般来说，对应容器中运行的进程，使日志输出到标准输出是一个比较好的方案，并且需要保存下来，以便需要的时候访问。

​		这里将容器进程的标准输出挂载到 /var/run/cocin_docker/容器名/container.log 文件中。调用cocin_docker logs的时候去读取这个文件，并将进程内的标准输出打印下来。

### 重定向输出

​		上节，如果用户没指定容器名，系统指派，但是那是在init进程之后。由于init容器日志逻辑的需要，把这个过程单独拿出来，提前了。

```go
func Run(tty bool, comArray []string, res *subsystems.ResourceConfig, volume, containerName string) {
   // 生成ID
   id := randStringBytes(containerIDLength)
   // 没指定名字，按照ID来
   if containerName == "" {
      containerName = id
   }
    ...
}
```

​		修改NewParentProcess函数，在这里进行重定向。

```go
/*
 这里是父进程，就是当前进程执行的内容
*/ // NewParentProcess
func NewParentProcess(tty bool, volume, containerName string) (*exec.Cmd, *os.File) {
   ...
   if tty {
      cmd.Stdin = os.Stdin
      cmd.Stdout = os.Stdout
      cmd.Stderr = os.Stderr
   } else {
      // 生成容器对应目录container.log
      dirURL := fmt.Sprintf(DefaultInfoLocation, containerName)
      if err := os.MkdirAll(dirURL, 0622); err != nil {
         log.Errorf("NewParentProcess mkdir %s error %v", dirURL, err)
         return nil, nil
      }
      stdLogFilePath := dirURL + ContainerLogFile
      stdLogFile, err := os.Create(stdLogFilePath)
      if err != nil {
         log.Errorf("NewParentProcess create file %s error %v", stdLogFilePath, err)
         return nil, nil
      }
      // 重定向
      cmd.Stdout = stdLogFile
   }
   ...
}
```

### 定义并实现logs命令

​		主函数注册

```go
// 定义基本命令
app.Commands = []cli.Command{
   initCommand,
   runCommand,
   commitCommand,
   listCommand,
   logCommand,
}
```

​		具体方法实现

```go
// log命令
var logCommand = cli.Command{
   Name:  "logs",
   Usage: "print logs of a container",
   Action: func(context *cli.Context) error {
      if len(context.Args()) < 1 {
         return fmt.Errorf("Please input your container name")
      }
      containerName := context.Args().Get(0)
      logContainer(containerName)
      return nil
   },
}
```

```go
func logContainer(containerName string) {
   // 找到对应文件夹的位置
   dirURL := fmt.Sprintf(container.DefaultInfoLocation, containerName)
   logFileLocation := dirURL + container.ContainerLogFile
   // 打开日志文件
   file, err := os.Open(logFileLocation)
   defer file.Close()
   if err != nil {
      log.Errorf("Log container open file %s error %v", logFileLocation, err)
      return
   }
   // 将文件内的内容都读取出来
   content, err := ioutil.ReadAll(file)
   if err != nil {
      log.Errorf("Log container read file %s error %v", logFileLocation, err)
      return
   }
   // 读取出来的内容重定向到标准输出
   fmt.Fprint(os.Stdout, string(content))
}
```

## 实现进入容器Namespace

​		实现 cocin_docker exec功能。

### setns

​		一个系统调用，根据PID再次进入到指定的Namespace中。需要先打开/proc/[pid]/ns/ 文件夹下对应的文件，然后使当前进程进入到指定的Namespace中。

​		对于Mount Namespace来说，一个具有多线程的进程是无法使用setns调用进入到对应的命名空间的。但是，Go每启动一个程序就会进入多线程状态，这里需要借助C来实现。

### Cgo

```go
/*
...
*/
import "C"
```

​		这段代码导入了C，但是实际上Go标准库没有这个包，那是因为这根本就不是一个真正的包，而是Cgo创建的一个特殊的命名空间，用来与C的命名空间交流。

### 使用C根据指定PID进入对应的命名空间

```go
package nsenter

/*
#include <errno.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>

// __attribute__((constructor)) 指的是，一旦这个包被引用，这个函数就会被自动执行
// 类似于构造函数，会在程序一启动的时候运行
__attribute__((constructor)) void enter_namespace(void) {
   char *mydocker_pid;
   // 从环境变量中获取需要进入PID
   mydocker_pid = getenv("cocin_docker_pid");
   if (mydocker_pid) {
      //fprintf(stdout, "got mydocker_pid=%s\n", mydocker_pid);
   } else {
      //fprintf(stdout, "missing mydocker_pid env skip nsenter");
      // 说明是父进程，直接退出
      return;
   }
   char *mydocker_cmd;
   // 从环境变量中获取需要执行的命令
   mydocker_cmd = getenv("cocin_docker_cmd");
   if (mydocker_cmd) {
      //fprintf(stdout, "got mydocker_cmd=%s\n", mydocker_cmd);
   } else {
      //fprintf(stdout, "missing mydocker_cmd env skip nsenter");
      // 没有指定命令，直接退出
      return;
   }
   int i;
   char nspath[1024];
   // 需要进入的5种Namespace
   char *namespaces[] = { "ipc", "uts", "net", "pid", "mnt" };

   for (i=0; i<5; i++) {
      // 拼接对应的路径 /proc/pid/ns/ipc 类似这样的
      sprintf(nspath, "/proc/%s/ns/%s", mydocker_pid, namespaces[i]);
      int fd = open(nspath, O_RDONLY);
      // 调用setns系统调用进入对应的Namespace  0代表：允许加入任何类型的 namespace
      if (setns(fd, 0) == -1) {
         //fprintf(stderr, "setns on %s namespace failed: %s\n", namespaces[i], strerror(errno));
      } else {
         //fprintf(stdout, "setns on %s namespace succeeded\n", namespaces[i]);
      }
      close(fd);
   }
   // 在进入的Namespace中执行指定的命令
   int res = system(mydocker_cmd);
   // 退出
   exit(0);
   return;
}
*/
import "C"
```

​		一旦这个包被引用，他就会在所有Go运行的环境启动之前执行，这样就避免了Go多线程导致的无法进入Namespace的问题。这段程序执行完毕以后，Go程序才会执行。

​		但是这会带来一个问题，就是只要这个包被导入，他就会在所有Go代码前执行，那么即使那些不需要使用exec这段代码的地方也会运行这段程序。这会影响前面已经完成的功能。因此需要在这段C代码前面一开始的位置就指定环境变量，对于不使用exec功能的Go代码，只要不设置对应的环境变量，那么当C程序检测到没有这个环境变量时，就会直接退出，继续执行原来的代码，不会影响原来的逻辑。

​		其实会发现，进入Namespace，就是进入对应的文件。

​		下面增加代码来实现exec功能。

### 添加命令并实现 exec

​		主函数注册，然后实现命令。

```go
// 定义基本命令
app.Commands = []cli.Command{
   initCommand,
   runCommand,
   commitCommand,
   listCommand,
   logCommand,
   execCommand,
}
```

```go
// exec命令
var execCommand = cli.Command{
   Name:  "exec",
   Usage: "exec a command into container",
   Action: func(context *cli.Context) error {
       // 当执行这个命令的时候，设置完环境变量，会重新打开一个子进程执行exec命令，这时候父进程可退出
      if os.Getenv(ENV_EXEC_PID) != "" {
         log.Infof("pid callback pid %s", os.Getpid())
         return nil
      }
      // 命令格式是 cocin_docker exec 容器名 命令
      if len(context.Args()) < 2 {
         return fmt.Errorf("Missing container name or command")
      }
      containerName := context.Args().Get(0)
      var commandArray []string
      // 将除了容器名以外的参数当作需要执行的命令处理  不是返回最后一个 源码实现是返回一个切片，除容器参数外的命令切片
      for _, arg := range context.Args().Tail() {
         commandArray = append(commandArray, arg)
      }
      // 执行命令
      ExecContainer(containerName, commandArray)
      return nil
   },
}
```

```go
import (
   "cocin_dokcer/container"
   _ "cocin_dokcer/nsenter"
   "encoding/json"
   "fmt"
   log "github.com/sirupsen/logrus"
   "io/ioutil"
   "os"
   "os/exec"
   "strings"
)

// ENV_EXEC_PID 和 ENV_EXEC_CMD 主要是为了控制是否执行C代码
const ENV_EXEC_PID = "cocin_docker_pid"
const ENV_EXEC_CMD = "cocin_docker_cmd"

// 根据提供的容器名，获取对应容器的PID 通过之前的后台运行信息来实现
func getContainerPidByName(containerName string) (string, error) {
   dirURL := fmt.Sprintf(container.DefaultInfoLocation, containerName)
   configFilePath := dirURL + container.ConfigName
   contentBytes, err := ioutil.ReadFile(configFilePath)
   if err != nil {
      return "", err
   }
   var containerInfo container.ContainerInfo
   // 将文件反序列化成容器信息对象，然后返回对应的PID
   if err := json.Unmarshal(contentBytes, &containerInfo); err != nil {
      return "", err
   }
   return containerInfo.Pid, nil
}

func ExecContainer(containerName string, comArray []string) {
   // 获取宿主机PID
   pid, err := getContainerPidByName(containerName)
   if err != nil {
      log.Errorf("Exec container getContainerPidByName %s error %v", containerName, err)
      return
   }
   // 把命令以空格为分隔符拼接成字符串，便于传递
   cmdStr := strings.Join(comArray, " ")
   log.Infof("container pid %s", pid)
   log.Infof("command %s", cmdStr)

   cmd := exec.Command("/proc/self/exe", "exec")

   cmd.Stdin = os.Stdin
   cmd.Stdout = os.Stdout
   cmd.Stderr = os.Stderr

   os.Setenv(ENV_EXEC_PID, pid)
   os.Setenv(ENV_EXEC_CMD, cmdStr)

   if err := cmd.Run(); err != nil {
      log.Errorf("Exec container %s error %v", containerName, err)
   }
}
```

​		这里有一个需要特别特别注意的地方，就是包的导入。没导入运行不了C代码。

```go
import _ "cocin_dokcer/nsenter"
```

​		就是通过 cmd := exec.Command("/proc/self/exe", "exec")，新打开一个进程，把自己再运行一遍。同时设置环境变量。由于再运行一遍。环境变量也设置了。然后开始执行新的进程的Go程序之前，会运行导入的C代码，C代码中创建了一个子进程用于运行命令，然后自己退出了。这时候这个C代码创建的子进程，就进入到了容器内。

​		整个过程一共创建了4个进程。

- 一开始运行exec命令创建一个进程，此时没有设置环境变量
- 在ExecContainer函数中，执行cmd := exec.Command("/proc/self/exe", "exec")，新打开一个进程（记为A），此时设置好环境变量了
- 这个新开的进程A，还没运行。导入包的时候，会先执行导入的C代码，C代码的运行有一个进程（记为B）
- 进程B中的system语句，又会fork一个子进程去执行命令，记为C，后面其实我们进入容器内，用的就是C进程。
- 然后B进程退出，然后这些工作搞定，就会去执行A的Go代码，根据代码逻辑，A中知道有环境变量设置了，exec就不需要再执行了，退出。
- 最开始的那个进程在阻塞等待（Run函数），现在A也退出了，运行完了，所以他也退出了。

## 实现容器的停止

​		主要就是查找到它的主进程PID，然后发送SIGTERM信号，等待进程结束就好。

### 添加并实现命令 stop

​		记得主函数添加，然后定义命令逻辑。

```go
var stopCommand = cli.Command{
	Name: "stop",
	Usage: "stop a container",
	Action: func(context *cli.Context) error {
		if len(context.Args()) < 1 {
			return fmt.Errorf("Missing container name")
		}
		containerName := context.Args().Get(0)
		stopContainer(containerName)
		return nil
	},
}
```

```go
// 根据容器名获取对应的struct结构
func getContainerInfoByName(containerName string) (*container.ContainerInfo, error) {
   dirURL := fmt.Sprintf(container.DefaultInfoLocation, containerName)
   configFilePath := dirURL + container.ConfigName
   contentBytes, err := ioutil.ReadFile(configFilePath)
   if err != nil {
      log.Errorf("Read file %s error %v", configFilePath, err)
      return nil, err
   }
   var containerInfo container.ContainerInfo
   if err := json.Unmarshal(contentBytes, &containerInfo); err != nil {
      log.Errorf("GetContainerInfoByName unmarshal error %v", err)
      return nil, err
   }
   return &containerInfo, nil
}

/*
   stopContainer 主要步骤如下
   1. 获取容器ID
   2. 对该PID发送kill信号
   3. 修改容器信息
   4. 重新写入存储容器信息的文件
*/
func stopContainer(containerName string) {
   // 获取主进程PID，杀掉容器主进程
   pid, err := getContainerPidByName(containerName)
   if err != nil {
      log.Errorf("Get contaienr pid by name %s error %v", containerName, err)
      return
   }
   pidInt, err := strconv.Atoi(pid)
   if err != nil {
      log.Errorf("Conver pid from string to int error %v", err)
      return
   }
   // 调用kill发送信号给进程，通过传递syscall.SIGTERM信号，去杀掉容器的主进程
   if err := syscall.Kill(pidInt, syscall.SIGTERM); err != nil {
      log.Errorf("Stop container %s error %v", containerName, err)
      return
   }
   // 根据容器名获得容器信息
   containerInfo, err := getContainerInfoByName(containerName)
   if err != nil {
      log.Errorf("Get container %s info error %v", containerName, err)
      return
   }
   // 修改信息后序列化写入，修改状态，PID置空
   containerInfo.Status = container.STOP
   containerInfo.Pid = " "
   newContentBytes, err := json.Marshal(containerInfo)
   if err != nil {
      log.Errorf("Json marshal %s error %v", containerName, err)
      return
   }
   dirURL := fmt.Sprintf(container.DefaultInfoLocation, containerName)
   configFilePath := dirURL + container.ConfigName
   if err := ioutil.WriteFile(configFilePath, newContentBytes, 0622); err != nil {
      log.Errorf("Write file %s error", configFilePath, err)
   }
}
```

​		总结一下，就是获取到主进程的ID，然后利用kill去停止主进程。因为容器的状态改变了，使用容器的记录信息也要改变。

## 实现删除容器

### 添加并实现rm命令

​		主函数注册。命令逻辑实现。主要是判断一下容器的状态，必须是STOP才能删除。然后把对应文件删除即可。

```go
// rm命令
var removeCommand = cli.Command{
   Name:  "rm",
   Usage: "remove unused containers",
   Action: func(context *cli.Context) error {
      if len(context.Args()) < 1 {
         return fmt.Errorf("Missing container name")
      }
      containerName := context.Args().Get(0)
      removeContainer(containerName)
      return nil
   },
}
```

```go
// 移除容器
func removeContainer(containerName string) {
   containerInfo, err := getContainerInfoByName(containerName)
   if err != nil {
      log.Errorf("Get container %s info error %v", containerName, err)
      return
   }
   if containerInfo.Status != container.STOP {
      log.Errorf("Couldn't remove running container")
      return
   }
   dirURL := fmt.Sprintf(container.DefaultInfoLocation, containerName)
   if err := os.RemoveAll(dirURL); err != nil {
      log.Errorf("Remove file %s error %v", dirURL, err)
      return
   }
}
```

## 实现通过容器制作镜像

​		之前运行多个容器，由于路径固定，用的都是同一个AUFS文件系统，容器的可写层会相互影响。本节主要做的是，为每个人容器分配单独的隔离文件系统。修改cocin_docker commit命令，实现对不同容器进行打包镜像的功能。

### 分配单独的隔离文件系统

​		每次运行容器，得指定是哪个镜像。因此，首先得修改run命令。







​		同时，也要把卷的信息单独拿出来，使用需要在记录信息中添加volume的信息。



​		修改NewWorkSpace，为每个容器创建文件系统。



​		修改CreateReadOnlyLayer，根据用户输入为每个容器创建只读层。镜像解压出来的只读层以RootUrl + imageName命名。







​		修改CreateWriteLayer函数的作用是为每个容器创建一个读写层。注意要把不同容器读写层分开。因此使用WriteLayerUrl + containerName命名。





​		还需要修改MountVolume函数，作用是根据用户输入的volume参数获取相应要挂载的宿主机数据卷URL和容器中的挂载点URL，然后挂载数据卷。容器的挂载点以MntUrl + containerName + containerUrl命名(这个是容器文件系统里面的路径)。





​		还有CreateMountPoint函数需要修改，它的作用是创建容器的根目录，然后把只读层和容器读写层挂载到容器根目录，成为容器文件系统。





​		创建部分的逻辑修改完以后，需要修改删除部分的逻辑。首先是DeleteWorkSpace。





​		然后便是DeleteMountPoint。删除未挂载数据卷的容器文件系统。



​		接下来就是DeleteMountPointWithVolume，删除挂载数据卷容器的文件系统。注意，数据卷是不删除的。之所以要额外写这个，是因为我们需要先把数据卷卸载下来。



​		还需要修改DeleteWriteLayer。

### 实现不同容器进行打包镜像的功能

​		首先要修改命令，看要打包的容器是哪个，打包出来的镜像叫什么。



​		然后修改commitContainer函数。制作{imageName}.tar的镜像



### 一些漏洞填充及解释

​		之前用docker的时候知道，当退出容器的时候，容器的数据是不会被删除的，只有在删除容器的时候，容器的数据才会被删除。而volume是用做持久化，容器是不会去删它的。

​		在这里，一开始我们的实现是，只要退出容器，就删除这些可写层数据。后来引入了detach模式，后台运行，修改逻辑的时候，改成下面这样的。

```go
if tty {
   parent.Wait()
   deleteContainerInfo(containerName)
   container.DeleteWorkSpace(volume, containerName)
}

os.Exit(-1)
```

​		因为一开始的实现是只要退出就删，所以之前一直很疑惑，如果不是attach模式，前台交互运行，那可写层就不删了？

​		突然发现现在这样其实更符合docker的运行方式。

​		如果是前台运行的，说明一开始就进入docker，docker里面只有一个主进程。这个时候执行退出，会杀死子进程，docker的处理方式是把容器停止了。随后可以用重启的方法开启。但是我们这里没写重启，所以我们的方法就是执行退出了，就把相应的文件删除。

​		后台运行更不用说，docker本身就不会去删这些数据，除非要移除容器。我们知道重新接入的话，会创建新的进程。即用的不是容器中的主进程，这个时候退出，并不会停止容器，容器还能运行，因为退出的时候终止的是这个新进程，不是容器的主进程。我们这里写了重新接入容器的命令，所以在后台运行的时候，退出的时候，我们退出的也不是主进程，所以我们不应该删除容器的数据，容器还在运行。

​		那应该在什么时候删除。当你打算移除容器的时候。实际上前台运行也应该是这样，只不过目前我们还没处理这部分。

​		一开始移除容器部分的代码是有漏洞的，一开始只是删除了内存临时文件系统中的登记信息，因为当时多个容器共用宿主机上的那几个文件夹，我们是把路径写死的。所以不能删。

​		现在已经把他们隔离开来了，就应该把这个地方填上。

```go
// 移除容器
func removeContainer(containerName string) {
	...
	// 移除容器的时候，可写层也要删除。
	container.DeleteWorkSpace(containerInfo.Volume, containerName)
}
```

