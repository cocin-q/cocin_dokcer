# 构建容器进阶

## 实现容器的后台运行

### 实现-d标签

```go
// run命令
var runCommand = cli.Command{
   ...
   Flags: []cli.Flag{ // 类似运行命令时使用 -- 来指定参数
      ...
      cli.BoolFlag{
         Name:  "d",
         Usage: "detach container",
      },
   },
   /* 这里是run命令执行的真正函数
   1. 判断参数是否包含command
   2. 获取用户指定的command
   3. 调用Run function 去准备启动容器
   */
   Action: func(context *cli.Context) error {
      ...
      detach := context.Bool("d")
      if tty && detach { // tty 相当于前台交互模式 detach是后台运行模式
         return fmt.Errorf("ti and d paramter can not both provided")
      }
      ...
      log.Infof("tty: %v", tty)
      Run(tty, cmdArray, resConf, volume)
      return nil
   },
}
```

​		记得修改Run中的逻辑，如果不是attach模式（前台交互），那parent就可以退出了。

```go
if tty {
   parent.Wait()

   mntURL := "/root/mnt/"
   rootURL := "/root/"
   container.DeleteWorkSpace(rootURL, mntURL, volume)
}
```

## 实现查看运行中的容器

​		利用docker ps命令实现查看有哪些容器在运行。主要是去约定好的位置查询一下容器的数据信息，然后显示出来，因此数据准备就显得尤为重要。

### 准备数据

​		关于容器的信息，比如PID、容器创建时间、容器运行命令等之前都没有记录，导致容器运行完用户就再也不知道它的信息了，因此需要把这部分信息保留下来。

#### 添加name标签

​		方便用户指定容器名字。

```go
cli.StringFlag{
   Name:  "name",
   Usage: "container name",
},

// 传递下去
Run(tty, cmdArray, resConf, volume, containerName)
```

#### ID生成器，唯一标识容器

```go
// ID 生成器
func randStringBytes(n int) string {
   letterBytes := "1234567890"
   rand.Seed(time.Now().UnixNano())
   b := make([]byte, n)
   for i := range b {
      b[i] = letterBytes[rand.Intn(len(letterBytes))]
   }
   return string(b)
}
```

#### 定义容器的基本信息

​		默认把容器基本信息以json的形式存储在宿主机的 /var/run/cocin_docker/容器名/config.json 文件里面。

```go
var (
   RUNNING             string = "running"
   STOP                string = "stopped"
   Exit                string = "exited"
   DefaultInfoLocation string = "/var/run/cocin_docker/%s/"
   ConfigName          string = "config.json"
)

type ContainerInfo struct {
   Pid         string `json:"pid"`        //容器的init进程在宿主机上的 PID
   Id          string `json:"id"`         //容器Id
   Name        string `json:"name"`       //容器名
   Command     string `json:"command"`    //容器内init运行命令
   CreatedTime string `json:"createTime"` //创建时间
   Status      string `json:"status"`     //容器的状态
}
```

#### 记录容器基本信息

```go
// 记录容器的基本信息
func recordContainerInfo(containerPID int, commandArray []string, containerName string) (string, error) {
   // 生成ID
   id := randStringBytes(containerIDLength)
   // 当前时间作为创建时间
   createTime := time.Now().Format("2006-01-02 15:04:05")
   command := strings.Join(commandArray, "")
   // 没指定名字，按照ID来
   if containerName == "" {
      containerName = id
   }
   // 生成容器信息结构体
   containerInfo := &container.ContainerInfo{
      Pid:         strconv.Itoa(containerPID),
      Id:          id,
      Name:        containerName,
      Command:     command,
      CreatedTime: createTime,
      Status:      container.RUNNING,
   }

   // json序列化
   jsonBytes, err := json.Marshal(containerInfo)
   if err != nil {
      log.Errorf("Record container info error %v", err)
      return "", err
   }
   jsonStr := string(jsonBytes)

   // 拼凑存储容器信息的路径
   dirUrl := fmt.Sprintf(container.DefaultInfoLocation, containerName)
   // 路径不存在，级联的创建 如果目录已经存在，也返回nil
   if err := os.MkdirAll(dirUrl, 0622); err != nil {
      log.Errorf("Mkdir error %s error %v", dirUrl, err)
      return "", err
   }
   fileName := dirUrl + "/" + container.ConfigName
   // 创建最终配置文件 如果文件已存在，会将文件清空
   file, err := os.Create(fileName)
   defer file.Close()
   if err != nil {
      log.Errorf("Create file %s error %v", fileName, err)
      return "", err
   }
   // 将json序列化后的数据写入文件
   if _, err := file.WriteString(jsonStr); err != nil {
      log.Errorf("File write string error %v", err)
      return "", err
   }
   return containerName, nil
}
```

​		需要在Run函数中加上调用。

```go
// 记录容器信息
containerName, err := recordContainerInfo(parent.Process.Pid, comArray, containerName)
if err != nil {
   log.Errorf("Record container info error %v", err)
   return
}
```

#### 删除容器相关信息

​		如果使用的是attach模式，那容器在退出后，需要删除相关信息。即把对应目录删除即可。

```go
func deleteContainerInfo(containerId string) {
   dirURL := fmt.Sprintf(container.DefaultInfoLocation, containerId)
   if err := os.RemoveAll(dirURL); err != nil {
      log.Errorf("Remove dir %s error %v", dirURL, err)
   }
}
```

```go
if tty {
   parent.Wait()
   deleteContainerInfo(containerName)
}
```

### 实现cocin_docker ps

​		所有的容器运行信息都被存储到 /var/run/cocin_docker/容器名 下，只要遍历这个目录下的容器就可以实现命令。

#### 添加ps命令

​		首先，主函数里面注册。

```go
// 定义基本命令
app.Commands = []cli.Command{
   initCommand,
   runCommand,
   commitCommand,
   listCommand,
}
```

​		定义命令的具体实现。

```go
// ps命令
var listCommand = cli.Command{
   Name:  "ps",
   Usage: "list all the containers",
   Action: func(context *cli.Context) error {
      ListContainers()
      return nil
   },
}
```

```go
// ListContainers 列出容器信息
func ListContainers() {
   // 找到存储信息的路径 /var/run/cocin_docker
   dirURL := fmt.Sprintf(container.DefaultInfoLocation, "")
   // "/var/run/cocin_docker/%s/" 需要把后面那个 / 去掉
   dirURL = dirURL[:len(dirURL)-1]
   // 读取该文件夹下面所有文件
   files, err := ioutil.ReadDir(dirURL)
   if err != nil {
      log.Errorf("Read dir %s error %v", dirURL, err)
      return
   }
   var containers []*container.ContainerInfo
   // 遍历文件夹下面的所有文件
   for _, file := range files {
      // 根据容器配置文件获得对应信息，然后转换成容器信息的对象
      tmpContainer, err := getContainerInfo(file)
      if err != nil {
         log.Errorf("Get container info error %v", err)
         continue
      }
      containers = append(containers, tmpContainer)
   }

   // 使用tabwriter.NewWriter 在控制台打印容器信息
   // tabwriter 是引用的 text/tabwriter 类库，用于在控制台打印对齐的表格
   w := tabwriter.NewWriter(os.Stdout, 12, 1, 3, ' ', 0)
   fmt.Fprint(w, "ID\tNAME\tPID\tSTATUS\tCOMMAND\tCREATED\n")
   for _, item := range containers {
      fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\t%s\n",
         item.Id,
         item.Name,
         item.Pid,
         item.Status,
         item.Command,
         item.CreatedTime)
   }
   if err := w.Flush(); err != nil {
      log.Errorf("Flush error %v", err)
      return
   }
}

// 因为具体的容器信息在对应容器文件夹下，所以这里需要进入文件夹取出信息
func getContainerInfo(file os.FileInfo) (*container.ContainerInfo, error) {
   // 获取文件名
   containerName := file.Name()
   // 根据文件名生成文件绝对路径
   configFileDir := fmt.Sprintf(container.DefaultInfoLocation, containerName)
   configFileDir = configFileDir + container.ConfigName
   // 读取信息
   content, err := ioutil.ReadFile(configFileDir)
   if err != nil {
      log.Errorf("Read file %s error %v", configFileDir, err)
      return nil, err
   }
   // json反序列化
   var containerInfo container.ContainerInfo
   if err := json.Unmarshal(content, &containerInfo); err != nil {
      log.Errorf("Json unmarshal error %v", err)
      return nil, err
   }
   return &containerInfo, nil
}
```

## 查看容器日志

​		一般来说，对应容器中运行的进程，使日志输出到标准输出是一个比较好的方案，并且需要保存下来，以便需要的时候访问。

​		这里将容器进程的标准输出挂载到 /var/run/cocin_docker/容器名/container.log 文件中。调用cocin_docker logs的时候去读取这个文件，并将进程内的标准输出打印下来。

### 重定向输出

​		上节，如果用户没指定容器名，系统指派，但是那是在init进程之后。由于init容器日志逻辑的需要，把这个过程单独拿出来，提前了。

```go
func Run(tty bool, comArray []string, res *subsystems.ResourceConfig, volume, containerName string) {
   // 生成ID
   id := randStringBytes(containerIDLength)
   // 没指定名字，按照ID来
   if containerName == "" {
      containerName = id
   }
    ...
}
```

​		修改NewParentProcess函数，在这里进行重定向。

```go
/*
 这里是父进程，就是当前进程执行的内容
*/ // NewParentProcess
func NewParentProcess(tty bool, volume, containerName string) (*exec.Cmd, *os.File) {
   ...
   if tty {
      cmd.Stdin = os.Stdin
      cmd.Stdout = os.Stdout
      cmd.Stderr = os.Stderr
   } else {
      // 生成容器对应目录container.log
      dirURL := fmt.Sprintf(DefaultInfoLocation, containerName)
      if err := os.MkdirAll(dirURL, 0622); err != nil {
         log.Errorf("NewParentProcess mkdir %s error %v", dirURL, err)
         return nil, nil
      }
      stdLogFilePath := dirURL + ContainerLogFile
      stdLogFile, err := os.Create(stdLogFilePath)
      if err != nil {
         log.Errorf("NewParentProcess create file %s error %v", stdLogFilePath, err)
         return nil, nil
      }
      // 重定向
      cmd.Stdout = stdLogFile
   }
   ...
}
```

### 定义并实现logs命令

​		主函数注册

```go
// 定义基本命令
app.Commands = []cli.Command{
   initCommand,
   runCommand,
   commitCommand,
   listCommand,
   logCommand,
}
```

​		具体方法实现

```go
// log命令
var logCommand = cli.Command{
   Name:  "logs",
   Usage: "print logs of a container",
   Action: func(context *cli.Context) error {
      if len(context.Args()) < 1 {
         return fmt.Errorf("Please input your container name")
      }
      containerName := context.Args().Get(0)
      logContainer(containerName)
      return nil
   },
}
```

```go
func logContainer(containerName string) {
   // 找到对应文件夹的位置
   dirURL := fmt.Sprintf(container.DefaultInfoLocation, containerName)
   logFileLocation := dirURL + container.ContainerLogFile
   // 打开日志文件
   file, err := os.Open(logFileLocation)
   defer file.Close()
   if err != nil {
      log.Errorf("Log container open file %s error %v", logFileLocation, err)
      return
   }
   // 将文件内的内容都读取出来
   content, err := ioutil.ReadAll(file)
   if err != nil {
      log.Errorf("Log container read file %s error %v", logFileLocation, err)
      return
   }
   // 读取出来的内容重定向到标准输出
   fmt.Fprint(os.Stdout, string(content))
}
```

## 实现进入容器Namespace

​		实现 cocin_docker exec功能。

### setns

​		一个系统调用，根据PID再次进入到指定的Namespace中。需要先打开/proc/[pid]/ns/ 文件夹下对应的文件，然后使当前进程进入到指定的Namespace中。

​		对于Mount Namespace来说，一个具有多线程的进程是无法使用setns调用进入到对应的命名空间的。但是，Go每启动一个程序就会进入多线程状态，这里需要借助C来实现。

### Cgo

```go
/*
...
*/
import "C"
```

​		这段代码导入了C，但是实际上Go标准库没有这个包，那是因为这根本就不是一个真正的包，而是Cgo创建的一个特殊的命名空间，用来与C的命名空间交流。

### 使用C根据指定PID进入对应的命名空间

```go
package nsenter

/*
#include <errno.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>

// __attribute__((constructor)) 指的是，一旦这个包被引用，这个函数就会被自动执行
// 类似于构造函数，会在程序一启动的时候运行
__attribute__((constructor)) void enter_namespace(void) {
   char *mydocker_pid;
   // 从环境变量中获取需要进入PID
   mydocker_pid = getenv("cocin_docker_pid");
   if (mydocker_pid) {
      //fprintf(stdout, "got mydocker_pid=%s\n", mydocker_pid);
   } else {
      //fprintf(stdout, "missing mydocker_pid env skip nsenter");
      // 说明是父进程，直接退出
      return;
   }
   char *mydocker_cmd;
   // 从环境变量中获取需要执行的命令
   mydocker_cmd = getenv("cocin_docker_cmd");
   if (mydocker_cmd) {
      //fprintf(stdout, "got mydocker_cmd=%s\n", mydocker_cmd);
   } else {
      //fprintf(stdout, "missing mydocker_cmd env skip nsenter");
      // 没有指定命令，直接退出
      return;
   }
   int i;
   char nspath[1024];
   // 需要进入的5种Namespace
   char *namespaces[] = { "ipc", "uts", "net", "pid", "mnt" };

   for (i=0; i<5; i++) {
      // 拼接对应的路径 /proc/pid/ns/ipc 类似这样的
      sprintf(nspath, "/proc/%s/ns/%s", mydocker_pid, namespaces[i]);
      int fd = open(nspath, O_RDONLY);
      // 调用setns系统调用进入对应的Namespace  0代表：允许加入任何类型的 namespace
      if (setns(fd, 0) == -1) {
         //fprintf(stderr, "setns on %s namespace failed: %s\n", namespaces[i], strerror(errno));
      } else {
         //fprintf(stdout, "setns on %s namespace succeeded\n", namespaces[i]);
      }
      close(fd);
   }
   // 在进入的Namespace中执行指定的命令
   int res = system(mydocker_cmd);
   // 退出
   exit(0);
   return;
}
*/
import "C"
```

​		一旦这个包被引用，他就会在所有Go运行的环境启动之前执行，这样就避免了Go多线程导致的无法进入Namespace的问题。这段程序执行完毕以后，Go程序才会执行。

​		但是这会带来一个问题，就是只要这个包被导入，他就会在所有Go代码前执行，那么即使那些不需要使用exec这段代码的地方也会运行这段程序。这会影响前面已经完成的功能。因此需要在这段C代码前面一开始的位置就指定环境变量，对于不使用exec功能的Go代码，只要不设置对应的环境变量，那么当C程序检测到没有这个环境变量时，就会直接退出，继续执行原来的代码，不会影响原来的逻辑。

​		下面增加代码来实现exec功能。

### 添加命令并实现

